Tier 1 – Core High-Yield Problems (≈40)
Strings (8)
[✔]    Longest Substring Without Repeating Characters – canonical sliding window / hash index.

[✔]    Longest Repeating Character Replacement – sliding window w/ max freq maintenance (tolerance k).

[HARD]    Minimum Window Substring – bi-directional counts; hardest window pattern.

[✔]    Group Anagrams – hashing canonical form; unordered_map usage.

[✔]    Decode String – stack of counts/strings; nested state machine.

[✔]    Longest Palindromic Substring – expand-around-center DP idea.

[✔]    Roman to Integer – parsing with lookahead; table-driven pattern.

[✔]    Evaluate Reverse Polish Notation – stack expression evaluation (typing, error checks).




Grid DFS/BFS (4)

[✔]    Number of Islands – flood-fill template (DFS/BFS, mark visited).

[✔]    Rotting Oranges – multi-source BFS + time layers.

[✔]    01 Matrix – BFS shortest distance to nearest zero (queue layering).

[✔]    Pacific Atlantic Water Flow – reverse-flow BFS/DFS from borders; teaches “search from destination set.”




Arrays / Two-Pointer & Prefix (8)

[✔]    3Sum – sort + two-pointer + de-dup.

[✔]    Subarray Sum Equals K – prefix sum + hash counts (handles negatives).

[✔]    Product of Array Except Self – prefix/suffix sweep, O(1) extra space.

Minimum Size Subarray Sum – sliding window for ≥ target (positives).

[✔]    Search in Rotated Sorted Array – modified binary search invariants.

[✔]    Trapping Rain Water – two-pointer vs. prefix-max arrays; spatial reasoning.

[✔]    Merge Intervals – sort + merge sweep; interval reasoning.

Sliding Window Maximum – deque monotonic queue pattern.



Graph / Topological & Shortest-Path (6)
[✔]    Course Schedule – detect cycle via topo indegree; core DAG pattern.

[✔]    Course Schedule II – topo ordering output variant.

Clone Graph – BFS/DFS with hash map for aliasing.

Reconstruct Itinerary – Eulerian path / lexical priority using multiset graph.

Network Delay Time – Dijkstra w/ priority_queue.

[HARD]    Alien Dictionary – topo from precedence constraints + cycle detect.





LRU / Small-Scale Design (4)
LRU Cache – doubly-linked list + hash; eviction pattern.

LFU Cache – freq buckets + LRU ties; multi-level bookkeeping.

Hit Counter – sliding time window; queue or circular buffer.

Design Underground System – start/stop timestamp aggregation; map of active trips + stats.





Heap / Selection (4)
Kth Largest Element in an Array – heap vs. quickselect trade-offs.

Find Median from Data Stream – two heaps w/ balance.

[✔]    Top K Frequent Elements – frequency map + heap / bucket.

Task Scheduler – greedy counts + idle slots or heap simulation.

Tree Recursion & BST (6)
Binary Tree Level Order Traversal – BFS pattern for trees (foundation).

Validate Binary Search Tree – passing value ranges; recursion invariants.

Lowest Common Ancestor of a Binary Tree – postorder recursion returning flags.

Serialize and Deserialize Binary Tree – pre/post/level encodings; null sentinels.

Diameter of Binary Tree – depth recursion returning (height, diameter).

Kth Smallest Element in a BST – inorder traversal / stack; order stats.




+++++++++++++++++++++++++++++
=============================================================================================
=============================================================================================
+++++++++++++++++++++++++++++




Tier 2 – Variants & Reinforcement Problems
(Group these by the Tier-1 problem they extend. Use them as “extra reps” if you finish Tier-1 early, or to stress-test understanding.)

Strings → Variants
[✔]    Valid Parentheses ← quick stack warm-up for Decode String.

String Compression ← two-pointer write index; in-place pattern.

Multiply Strings ← manual big-int multiply; indexing loops (good C++ string/vec practice).

Find the Index of the First Occurrence in a String (KMP optional) ← pattern-matching variant.

Zigzag Conversion ← coordinate mapping exercise.

Integer to Roman ← inverse of Roman to Integer.

Remove All Adjacent Duplicates in String ← stack/2-pointer deletion.

Grid → Variants
[✔]    Max Area of Island ← Number of Islands but track component size.

[✔]    Walls and Gates ← multi-source BFS with obstacles.

[✔]    Surrounded Regions ← flood from borders to protect cells.

Shortest Path in Binary Matrix ← BFS with 8-dirs + distance count.

[✔]    Island Perimeter ← counting edges after flood fill.

Escape Large Maze ← BFS with pruning / boundary conditions.

Arrays → Variants
[✔]    3Sum Closest ← tweak scoring in 3Sum.

Kth Missing Positive Number ← binary search gaps; sorted arr reasoning.

[✔]    Container With Most Water ← two-pointer area maximization.

[✔]    Best Time to Buy and Sell Stock II ← greedy accumulation; pattern for profit scanning.

Longest Consecutive Sequence ← hash set sequence growth.

Insert Delete GetRandom O(1) ← design (hash + array) pattern linking to LRU/LFU.

Graph → Variants
Keys and Rooms ← reachability BFS (Clone Graph light).

Minimum Height Trees ← trim leaves (topo peel) variant of Course Schedule thinking.

Dijkstra’s Shortest Path in Grid (#1514 Path w/ Max Prob) ← weighted traversal variant.

Evaluate Division ← graph w/ edge weights; BFS or union-find ratio composition.

Design → Variants
Design Circular Deque ← index arithmetic; container mgmt.

Design Twitter ← feed merge (heap + timestamps).

Logger Rate Limiter ← throttling variant of Hit Counter.

Moving Average from Data Stream ← fixed-size queue + running sum.

Heap / Selection → Variants
Merge k Sorted Lists ← k-way heap merge; memory mgmt in C++.

K Closest Points to Origin ← bounded heap pattern.

Reorganize String ← max-heap char counts; adjacency constraint.

Sliding Window Median ← two heaps + lazy deletion.

Trees → Variants
Binary Tree Zigzag Level Order Traversal ← Level Order + direction flag.

Binary Tree Right Side View ← BFS depth capture.

Path Sum III ← prefix sum path counts in tree.

Convert Sorted Array to BST ← recursive divide; BST invariants.



HARD PROBLEMS:

716 · Max Stack (and occasionally 
895 · Maximum Frequency Stack)






75 from deepresearch


1. Array
[✔]    Two Sum

[✔]    Best Time to Buy and Sell Stock

[✔]    Contains Duplicate

[✔]    Product of Array Except Self

[✔]    Maximum Subarray

[✔]    Maximum Product Subarray

[✔]    Find Minimum in Rotated Sorted Array

[✔]    Search in Rotated Sorted Array

[✔]    3Sum

[✔]    Container With Most Water


2. Binary (Bit Manipulation)
Sum of Two Integers – (Implement addition without + using bit operations)
Number of 1 Bits – (Count set bits in an integer, a.k.a. Hamming weight)
Counting Bits – (Count set bits for all numbers up to n, often using DP or bit tricks)
Missing Number – (Find the missing number in 0..n, often using XOR or Gauss sum)
Reverse Bits – (Reverse the bit order of a 32-bit integer)


3. Dynamic Programming
Climbing Stairs – (Basic DP: ways to climb 1 or 2 steps at a time)

Coin Change – (DP to make change with minimum coins)

Longest Increasing Subsequence – (Classic DP or patience sorting method)

[✔]    Longest Common Subsequence – (DP for LCS problem)

Word Break – (DP to check if a string can be segmented into dictionary words)

Combination Sum – (Backtracking/DFS to find combinations summing to target)

House Robber – (DP to maximize non-adjacent house loot)
House Robber II – (Variation of House Robber on a circular arrangement)
Decode Ways – (DP to count decodings of a digit string)
Unique Paths – (Combinatorics or DP for grid paths count)
Jump Game – (Greedy or DP to check if you can reach the end of array)


4. Graph / Tree (Graph Algorithms)
Clone Graph – (DFS/BFS to copy a graph)
[✔]    Course Schedule – (Topological sort to detect if all courses can be finished)
[✔]    Pacific Atlantic Water Flow – (Matrix DFS/BFS from ocean boundaries)
[✔]    Number of Islands – (DFS/BFS to count connected components in grid)
[✔]    Longest Consecutive Sequence – (Use HashSet to find longest consecutive integer sequence)
Alien Dictionary (LeetCode Premium) – (Topological sort for custom alphabet order)
Graph Valid Tree (LeetCode Premium) – (Union-Find or DFS to check if acyclic connected graph)
Number of Connected Components in an Undirected Graph (LeetCode Premium) – (Union-Find or DFS to count components)


5. Interval Scheduling/Merging
Insert Interval – (Insert an interval into sorted intervals and merge overlaps)
[✔]    Merge Intervals – (Merge overlapping intervals in a list)
Non-overlapping Intervals – (Erase minimum intervals to avoid overlaps, greedy scheduling)
Meeting Rooms (LeetCode Premium) – (Check if a person can attend all meetings, sort intervals)
Meeting Rooms II (LeetCode Premium) – (Minimum number of conference rooms required, use min-heap)


6. Linked List
Reverse Linked List – (Iterative or recursive reversal of a singly linked list)
Detect Cycle in Linked List – (Floyd’s cycle-finding algorithm – tortoise & hare)
Merge Two Sorted Lists – (Merge two sorted linked lists into one sorted list)
Merge K Sorted Lists – (Use a min-heap or divide-and-conquer to merge k lists)
Remove Nth Node From End – (Two-pointer technique to remove nth from end in one pass)
Reorder List – (Reorder L0→L_last→L1→L_last-1… by splitting and merging list)


7. Matrix
Set Matrix Zeroes – (Mark rows/cols to zero out in a matrix in-place)
Spiral Matrix – (Traverse matrix in spiral order)
Rotate Image – (Rotate matrix by 90 degrees in-place)
Word Search – (Backtracking DFS to find a word in a grid)


8. String
[✔]    Longest Substring Without Repeating Characters – (Sliding window technique for max unique-substring length)
[✔]    Longest Repeating Character Replacement – (Sliding window with character counts for replacement operations)
Minimum Window Substring – (Sliding window to find the smallest substring containing all target chars)
[✔]    Valid Anagram – (Check if two strings are anagrams – frequency counting)
[✔]    Group Anagrams – (Use sorted string or count signature as key to group anagram lists)
[✔]    Valid Parentheses – (Use a stack to validate matching parentheses)
[✔]    Valid Palindrome – (Two-pointer check for palindrome, ignoring non-alphanumeric)
Longest Palindromic Substring – (Expand-around-center or DP to find longest palindrome in a string)
Palindromic Substrings – (Count all palindromic substrings in a string)
Encode and Decode Strings (LeetCode Premium) – (Design an encoding scheme to serialize/de-serialize a list of strings)


9. Tree / Binary Search Tree
Maximum Depth of Binary Tree – (DFS to find tree height)
Same Tree – (Check if two binary trees are identical by DFS)
Invert/Flip Binary Tree – (Swap children of every node – classic invert binary tree)
Binary Tree Maximum Path Sum – (DFS track max path through each node, consider splits)
Binary Tree Level Order Traversal – (BFS by levels of the tree)
Serialize and Deserialize Binary Tree – (Encode tree to string and decode back, BFS or DFS)
Subtree of Another Tree – (Check if one tree is a subtree of another)
Construct Binary Tree from Preorder and Inorder Traversal – (Reconstruct a tree using preorder & inorder arrays)
Validate Binary Search Tree – (Inorder traversal or recursion to verify BST property)
Kth Smallest Element in a BST – (Inorder traversal (BST gives sorted order) to find kth item)
Lowest Common Ancestor of a BST – (Find LCA in BST by utilizing BST properties)
Implement Trie (Prefix Tree) – (Design a Trie data structure for words)
Add and Search Word (Data Structure Design) – (Design a Word Dictionary with wildcard support using Trie)
Word Search II – (Find all words from a list in a grid, using Trie + DFS/backtracking)

Heap / Selection (4)
Kth Largest Element in an Array – heap vs. quickselect trade-offs.

[✔]    Top K Frequent Elements – frequency map + heap / bucket.

Task Scheduler – greedy counts + idle slots or heap simulation.

Diameter of Binary Tree – depth recursion returning (height, diameter).


10. Heap (Priority Queue)
[✔]    Top K Frequent Elements – (Use a heap or bucket counting to get k most frequent numbers)
Find Median from Data Stream – (Maintain two heaps for lower and higher halves to get median in O(log n))

(Note: “Merge K Sorted Lists” was already listed under Linked List, and it’s often solved via a min-heap as well.)